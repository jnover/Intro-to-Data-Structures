Name: John Nover
Assignment: 4

Design:
	So I was responsible for the decoder. For my design, I figured that I wanted many functions to do the simple tasks, such as checking if a file contained the key (my checkFile function) or grabbing the encoded file size from the file (fileLength). My decoder REQUIRES the -i flag, meaning that I do not take input from stdin like Prof. Long's decoder does, as I saw that in the PDF, it states the -i flag is REQUIRED. However, I do not require an -o flag. Next, my program gathers the needed information to build the tree. I collect the tree size, which is 2 bytes, stored in a uint16_t which is 2 bytes. I then create the tree using the parseTree function, which reads in 1 byte at a time, and checks if that byte matches an I or L. If it matches an L, then I read in one more byte and create a treeNode with the bool leaf set to 1, marking it as a leaf node of the tree. If the byte read in matches an I, then I pop once on the stack and call that item popped as the right treeNode, and pop once more on the stack and call that item popped left treeNode. I then join() the tree nodes in the variable root. In the way I wrote my function, I made it so that I did not need to pop() once more on the stack to receive the root node, as i had already stored it's address in the variable root from the final join(), therefore popping it again would be unnecessary. I then free the treeStack. Next, I have a function decodeTree, which takes in file to read from, a file to output to, a tree to build the decoded parts from, and the size of the file. The fileSize variable is passed because I need to know when to stop reading the file, which is when I have successfully decoded the number of bytes that is the same as the original file. When all bytes are read, the function ends. After all of this is complete, I delete the tree using a sick recursive function that I thought of in like 5 seconds.

My partner wrote the encode.c part. We also made separate huffman.c's because we each didn't need all of the functions that were specified in huffman.h. The only times we really met were at the assignment4 help sessions, and very recently to combine all of our files in the same Makefile and make sure nothing interferes with eachother. We didn't really require much help from eachother, however I helped my partner with little things such as understanding Little Endian vs Big Endian, because when he was outputting the encoded part originally, he was writing his binary in reverse. We also spent a little bit just talking to eachother and understanding what the order of the encoded file would look like. Overall though, we mostly only discussed little things with eachother, like what the verbose flag prints out. 


Files included -

stack.c: Includes stack.h, This is where the stack data structure is defined and includes it's main functions. 

huffman.c: Includes huffman.h, this is where the huffman tree data structure is defined and includes it's main functions. 

decode.c: The main file for the decoder, includes various helper functions to simplify some tasks.


In conclusion:
	I think this was a really nice assignment, I learned a lot more in this one that the previous few. I think the tree data structure is very cool, especially since several months ago I was trying to write program that usedtrees and pathfinding algorithms like A*, but I really had no idea what any of that stuff meant at the time. I think I picked up the understanding of huffman trees and stacks pretty quickly, and I had no trouble writing the functions for them. The biggest thing that frustrated me most, is that originally when I wrote my parseTree function, I had a counter that reads in the number of bytes that is the length of the tree. However, when there was an L, it meant that i must read in one more byte, so I'd read in one more byte but forgot to increment the i counter. This meant that for some time I was reading in more than the length of the tree, meaning that in the decodeFile function, my file Pointers were off, and so everytime I tried decoding a file, I would always get jibberish no matter what. So that single bug took me like 2 days to fix, because I was looking everywhere except in that one parseTree function. One thing I wish I would've learned is how to use memory mapping to write to a virtual file. My partner tried to explain that to me, however I just decided I wouldn't use it because we didn't learn it. He did say that Yash or someone had posted a tutorial somewhere on piazza but I didn't find it. So that is the reason why i think that my program is like 10x slower than Prof. Long's, because I do many more write function calls than he does, and I do mine directly to the file, rather than a virtual file.


